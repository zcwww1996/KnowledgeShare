[TOC]

# 1. 垃圾回收算法
主要有**复制**、**标记清除**、**标记整理**三种实现算法。

## 1.1 标记 - 清除算法

标记清除算法是最基础的收集算法，其他收集算法都是基于这种思想。标记清除算法分为“标记”和“清除”两个阶段：首先标记出需要回收的对象，标记完成之后统一清除对象。

<font color="red">主要缺点</font>：

①.标记和清除过程效率不高 

②.标记清除之后会产生大量不连续的内存碎片。

## 1.2 复制算法 

它将可用内存容量划分为大小相等的两块，每次只使用其中的一块。当这一块用完之后，就将还存活的对象复制到另外一块上面，然后在把已使用过的内存空间一次清理掉。这样使得每次都是对其中的一块进行内存回收，不会产生碎片等情况，只要移动堆订的指针，按顺序分配内存即可，实现简单，运行高效。

<font color="red">主要缺点</font>：

内存缩小为原来的一半。

## 1.3 标记 - 整理算法

标记操作和“标记-清除”算法一致，后续操作不只是直接清理对象，而是在清理无用对象完成后让所有存活的对象都向一端移动，并更新引用其对象的指针。

<font color="red">主要缺点</font>：

在标记-清除的基础上还需进行对象的移动，成本相对较高，好处则是不会产生内存碎片。


## 1.4 引用计数算法

引用计数收集器采用的是分散式管理方式，通过计数器记录对象是否被引用。当计数器为0时说明此对象不在被使用，可以被回收。

<font color="red">主要缺点</font>：

循环引用的场景下无法实现回收

## 1.5 分代收集算法（generation collection）

新生代（YOUNG generation） 朝生夕灭——大批对象死亡（存活的很少）用复制算法

老年代（Old generation）存活率高，用标记-删除或者标记-整理


# 2. 四种类型的垃圾回收器

1)  串行垃圾回收器（Serial Garbage Collector）

2)  并行垃圾回收器（Parallel Garbage Collector）

3)  并发标记扫描垃圾回收器（CMS Garbage Collector）

4) G1垃圾回收器（G1 Garbage Collector）


# 3. JVM内存空间图解

[![JVM内存空间图解](https://s2.ax1x.com/2020/01/06/ls5SNF.png)](https://i.loli.net/2020/01/06/LtZylibh3fxVRSs.png)

**程序计数器**：线程私有。是一块较小的内存，是当前线程所执行的字节码的行号指示器。是Java虚拟机规范中唯一没有规定OOM（OutOfMemoryError）的区域。

**Java栈**：线程私有。生命周期和线程相同。是Java方法执行的内存模型。执行每个方法都会创建一个栈帧，用于存储局部变量和操作数（对象引用）。局部变量所需要的内存空间大小在编译期间完成分配。所以栈帧的大小不会改变。存在两种异常情况：若线程请求深度大于栈的深度，抛StackOverflowError。若栈在动态扩展时无法请求足够内存，抛OOM。

**Java堆**：所有线程共享。虚拟机启动时创建。存放对象实例和数组。所占内存最大。分为新生代（Young区），老年代（Old区）。新生代分Eden区，Servior区。Servior区又分为From space区和To Space区。Eden区和Servior区的内存比为8:1。 当扩展内存大于可用内存，抛OOM。

**方法区**：所有线程共享。用于存储已被虚拟机加载的类信息、常量、静态变量等数据。又称为非堆（Non – Heap）。方法区又称“永久代”。GC很少在这个区域进行，但不代表不会回收。这个区域回收目标主要是针对常量池的回收和对类型的卸载。当内存申请大于实际可用内存，抛OOM。

**本地方法栈**：线程私有。与Java栈类似，但是不是为Java方法（字节码）服务，而是为本地非Java方法服务。也会抛StackOverflowError和OOM。


<font color="red">**有哪些方法可以判断一个对象已经可以被回收，JVM怎么判断一个对象已经消亡可以被回收？**</font>

**①引用计数算法**

给对象中添加一个引用计数器，每当有一个地方引用它时，计数器就加1；当引用失效时，计数器值就减1；任何时刻计数器都为0的对象就是不可能再被使用的。

ps：**Java语言<font style="background-color: yellow;">没有选用</font>引用计数法来管理内存**，因为引用计数法不能很好的解决循环引用的问题。

**②根搜索算法** 

在主流的商用语言中，都是使用根搜索算法来判定对象是否存活的。

GC Root Tracing 算法思路就是通过一系列的名为"GC  Roots"的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链（Reference Chain），当一个对象到GC Roots没有任何引用链相连，即从GC Roots到这个对象不可达，则证明此对象是不可用的。

[![ls4zAU.jpg](https://s2.ax1x.com/2020/01/06/ls4zAU.jpg)](https://i.loli.net/2020/01/06/zoxN3u9mRp6sZQS.jpg)

# 4. GC 触发条件

## 4.1 Minor GC触发条件
当Eden区满时，触发Minor GC。


## 4.2 Full GC触发条件
1) 调用System.gc时，系统建议执行Full GC，但是不必然执行
2) 老年代空间不足
3) 方法区空间不足
4) 通过Minor GC后进入老年代的平均大小大于老年代的可用内存
5) 由Eden区、From Space区向To Space区复制时，对象大小大于To Space可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小

来源： http://blog.csdn.net/yhyr_ycy/article/details/52566105

# 5. JVM调优
## 5.1 什么时候调？

通过监控系统（如没有现成的系统，自己做一个简单的上报监控的系统也很容易）上对一些机器关键指标（gc time、gc count、各个分代的内存大小变化、机器的Load值与CPU使用率、JVM的线程数等）的监控报警，也可以看gc log和jstat等命令的输出，再结合线上JVM进程服务的一些关键接口的性能数据和请求体验，基本上就能定位出当前的JVM是否有问题，以及是否需要调优。

## 5.2 怎么调？

1. 如果发现高峰期CPU使用率与Load值偏大，这个时候可以观察一些JVM的thread count以及gc count（可能主要是young gc count），如果这两个值都比以往偏大（也可以和一个历史经验值作对比），基本上可以定位是young gc频率过高导致，这个时候可以通过适当增大young区大小或者占比的方式来解决。

2. 如果发现关键接口响应时间很慢，可以结合gc time以及gc log中的stop the world的时间，看一下整个应用的stop the world的时间是不是比较多。如果是，可能需要减少总的gc time，具体可以从减小gc的次数和减小单次gc的时间这两个维度来考虑，一般来说，这两个因素是一对互斥因素，我们需要根据实际的监控数据来调整相应的参数（比如新生代与老生代比值、eden与survivor比值、MTT值、触发cms回收的old区比率阈值等）来达到一个最优值。

3. 如果发生full gc或者old cms gc非常频繁，通常这种情况会诱发STW的时间相应加长，从而也会导致接口响应时间变慢。这种情况，大概率是出现了“内存泄露”，Java里的内存泄露指的是一些应该释放的对象没有被释放掉（还有引用拉着它）。那么这些对象是如何产生的呢？为啥不会释放呢？对应的代码是不是出问题了？问题的关键是搞明白这个，找到相应的代码，然后对症下药。所以问题的关键是转化成寻找这些对象。怎么找？综合使用**jmap和MAT**，基本就能定位到具体的代码。

来源： https://tech.meituan.com/performance_tunning.html